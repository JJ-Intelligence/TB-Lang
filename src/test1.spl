-- Challenge 1, solution 1
func solve ([], bs) = []; 
func solve (a:[], bs) = []; 
func solve (x:y:as, z:bs) = x : y : z : solve (as, bs);

func buildInput (0) = [];
func buildInput (c) = 1 : buildInput (c-1);

-- Building/simulating the inputs.
-- x = 0;
-- as = [];
-- bs = [];
-- while ( x < 1000000) {
--     x = x + 1;
--     as = 1:as;
--     -- bs = 2:bs;
-- };

-- as = buildInput (1000000);
-- bs = buildInput (2, 1000000);

-- out(length (as));

-- solve (as, bs);

func head2 (xs) = head (xs);
func test (f, xs) = f (xs);

out(test(head2, [1,2,3]));

out(head([4,5,6]))


-- TODO:
-- call-by-reference - &xs gets the address of xs, and can be used to pass into functions (like C)
-- pop - remove item from a list and return it
-- peek - look at the item from the top of the list
-- drop - drop n items from the list
-- take - take n items from the list

-- add pre-defined functions to Env and Store so we can pass them as higher-order functions.