-- Challenge 1, solution 1
-- func solve ([], bs) = []; 
-- func solve (a:[], bs) = []; 
-- func solve (x:y:as, z:bs) = x : y : z : solve (as, bs);

-- func buildInput (0) = [];
-- func buildInput (c) = 1 : buildInput (c-1);

-- Building/simulating the inputs.
-- x = 0;
-- as = [];
-- bs = [];
-- while ( x < 1000000) {
--     x = x + 1;
--     as = 1:as;
--     -- bs = 2:bs;
-- };

-- as = buildInput (1000000);
-- bs = buildInput (2, 1000000);

-- out(length (as));

-- solve (as, bs);

-- func head2 (xs) = head (xs);
-- func test (f, xs) = f (xs);

-- out(test(head2, [1,2,3]));

-- out(head([4,5,6]))


-- TODO:
-- call-by-reference - &xs gets the address of xs, and can be used to pass into functions (like C)
-- pop - remove item from a list and return it
-- peek - look at the item from the top of the list
-- drop - drop n items from the list
-- take - take n items from the list

-- add pre-defined functions to Env and Store so we can pass them as higher-order functions.

out([1,2]);

-- selectInput([1,2,3]);

-- xs = inp(1);


-- Store:
-- (-1) -> VStream Int [VInt 2, ...]
-- (-2) -> VStream Int []
-- (-3) -> VStream Int []


-- xs -> (1) -> VStream Int [VInt 2, ...]
-- VList [VInt 2, ...] <-






xs = [];  
rs = ref(xs); 
rs = 1:rs ** Updates the value of xs.
as = dref (rs) ** Creates a copy of xs and binds the copy to as' address.


xs -> 1 -> VList []
rs -> 2 -> Ref 1

rs -> 2 -> Ref 1
xs => -> 1 -> VList [1]


as -> 3 -> VList [1]
as -> 3 -> VList [1,2]

VRef Address

